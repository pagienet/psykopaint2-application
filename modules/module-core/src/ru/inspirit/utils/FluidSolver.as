package ru.inspirit.utils {	/*********************************************************************** 	* This is a class for solving real-time fluid dynamics simulations based on Navier-Stokes equations 	* and code from Jos Stam's paper "Real-Time Fluid Dynamics for Games" http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/GDC03.pdf	* Other useful resources and implementations I looked at while building this lib: 	* Mike Ash (C) - http://mikeash.com/?page=pyblog/fluid-simulation-for-dummies.html	* Alexander McKenzie (Java) - http://www.multires.caltech.edu/teaching/demos/java/stablefluids.htm	* Pierluigi Pesenti (AS3 port of Alexander's) - http://blog.oaxoa.com/2008/01/21/actionscript-3-fluids-simulation/	* Gustav Taxen (C) - http://www.nada.kth.se/~gustavt/fluids/	* Dave Wallin (C++) - http://nuigroup.com/touchlib/ (uses portions from Gustav's)		/*********************************************************************** 	Copyright (c) 2008, 2009, Memo Akten, www.memo.tv	*** The Mega Super Awesome Visuals Company ***	/**	 * AS3 Port	 * @author Eugene Zatepyakin	 * @link http://blog.inspirit.ru/?p=248	 * @link http://code.google.com/p/in-spirit/source/browse/#svn/trunk/projects/FluidSolver	 */	public final class FluidSolver 	{		public static var FLUID_DEFAULT_NX:Number						= 50;		public static var FLUID_DEFAULT_NY:Number						= 50;		public static var FLUID_DEFAULT_DT:Number						= 1.0;		public static var FLUID_DEFAULT_VISC:Number						= 0.0001;		public static var FLUID_DEFAULT_COLOR_DIFFUSION:Number 			= 0.0;		public static var FLUID_DEFAULT_FADESPEED:Number				= 0.3;		public static var FLUID_DEFAULT_SOLVER_ITERATIONS:int			= 10;		public static var FLUID_DEFAULT_VORTICITY_CONFINEMENT:Boolean 	= false;			public var r:Vector.<Number>;		public var g:Vector.<Number>;		public var b:Vector.<Number>;				public var u:Vector.<Number>;		public var v:Vector.<Number>;			public var rOld:Vector.<Number>;		public var gOld:Vector.<Number>;		public var bOld:Vector.<Number>;				public var uOld:Vector.<Number>;		public var vOld:Vector.<Number>;				public var curl_abs:Vector.<Number>;		public var curl_orig:Vector.<Number>;				public var width:int;		public var height:int;				public var numCells:int;				protected var _NX:int, _NY:int, _NX2:int, _NY2:int;		protected var _invNumCells:Number;		protected var _dt:Number;		protected var _solverIterations:int;		protected var _colorDiffusion:Number;				protected var _visc:Number;		protected var _fadeSpeed:Number;				protected var _tmp:Vector.<Number>;				protected var _avgDensity:Number;			// this will hold the average color of the last frame (how full it is)		protected var _uniformity:Number;			// this will hold the uniformity of the last frame (how uniform the color is);		protected var _avgSpeed:Number;				public function FluidSolver(NX:int, NY:int)		{			setup(NX, NY);		}				public function setup(NX:int, NY:int):void		{			_dt = FLUID_DEFAULT_DT;			_fadeSpeed = FLUID_DEFAULT_FADESPEED;			_solverIterations = FLUID_DEFAULT_SOLVER_ITERATIONS;			_colorDiffusion = FLUID_DEFAULT_COLOR_DIFFUSION;						_NX = NX;			_NY = NY;			_NX2 = _NX + 2;			_NY2 = _NY + 2;						numCells = _NX2 * _NY2;						_invNumCells = 1.0 / numCells;						width = _NX2;			height = _NY2;						reset();		}				public function reset():void 		{						const fixed:Boolean = false;						r    = new Vector.<Number>(numCells, fixed);			rOld = new Vector.<Number>(numCells, fixed);						g    = new Vector.<Number>(numCells, fixed);			gOld = new Vector.<Number>(numCells, fixed);						b    = new Vector.<Number>(numCells, fixed);			bOld = new Vector.<Number>(numCells, fixed);						u    = new Vector.<Number>(numCells, fixed);			uOld = new Vector.<Number>(numCells, fixed);			v    = new Vector.<Number>(numCells, fixed);			vOld = new Vector.<Number>(numCells, fixed);						curl_abs = new Vector.<Number>(numCells, fixed);			curl_orig = new Vector.<Number>(numCells, fixed);						var i:int = numCells;			while ( --i > -1 ) {				u[i] = uOld[i] = v[i] = vOld[i] = 0.0;				r[i] = rOld[i] = g[i] = gOld[i] = b[i] = bOld[i] = 0;				curl_abs[i] = curl_orig[i] = 0;			}		}							/**		 * this must be called once every frame to move the solver one step forward 		*/		public function update():void 		{			addSourceUV();						swapUV();						diffuseUV(_visc);						project(u, v, uOld, vOld);						swapUV();						advect(1, u, uOld, uOld, vOld);			advect(2, v, vOld, uOld, vOld);						project(u, v, uOld, vOld);									addSourceRGB();			swapRGB();						if( _colorDiffusion != 0 && _dt != 0 )            {				diffuseRGB(_colorDiffusion);				swapRGB();            }						advectRGB(u, v);						fadeRGB();					}				protected function fadeR():void 		{			const holdAmount:Number = 1 - _fadeSpeed;						_avgDensity = 0;			_avgSpeed = 0;						var totalDeviations:Number = 0;			var currentDeviation:Number;			var tmp_r:Number;						var i:int = numCells;			while ( --i > -1 ) {				// clear old values				uOld[i] = vOld[i] = 0; 				rOld[i] = 0;								// calc avg speed				_avgSpeed += u[i] * u[i] + v[i] * v[i];								// calc avg density				tmp_r = Math.min(1.0, r[i]);				_avgDensity += tmp_r;	// add it up								// calc deviation (for uniformity)				currentDeviation = tmp_r - _avgDensity;				totalDeviations += currentDeviation * currentDeviation;								// fade out old				r[i] = tmp_r * holdAmount;			}			_avgDensity *= _invNumCells;						_uniformity = 1.0 / (1 + totalDeviations * _invNumCells);		// 0: very wide distribution, 1: very uniform		}				protected function fadeRGB():void 		{			const holdAmount:Number = 1 - _fadeSpeed;						_avgDensity = 0;			_avgSpeed = 0;						var totalDeviations:Number = 0;			var currentDeviation:Number;			var density:Number;						var tmp_r:Number, tmp_g:Number, tmp_b:Number;						var i:int = numCells;			while ( --i > -1 ) {				// clear old values				uOld[i] = vOld[i] = 0; 				rOld[i] = 0;				gOld[i] = bOld[i] = 0;								// calc avg speed				_avgSpeed += u[i] * u[i] + v[i] * v[i];								// calc avg density				tmp_r = Math.min(1.0, r[i]);				tmp_g = Math.min(1.0, g[i]);				tmp_b = Math.min(1.0, b[i]);								density = Math.max(tmp_r, Math.max(tmp_g, tmp_b));				_avgDensity += density;	// add it up								// calc deviation (for uniformity)				currentDeviation = density - _avgDensity;				totalDeviations += currentDeviation * currentDeviation;								// fade out old				r[i] = tmp_r * holdAmount;				g[i] = tmp_g * holdAmount;				b[i] = tmp_b * holdAmount;							}			_avgDensity *= _invNumCells;			_avgSpeed *= _invNumCells;						_uniformity = 1.0 / (1 + totalDeviations * _invNumCells);		// 0: very wide distribution, 1: very uniform		}				protected function addSourceUV():void 		{			var i:int = numCells;			while ( --i > -1 ) {				u[i] += _dt * uOld[i];				v[i] += _dt * vOld[i];			}		}				protected function addSourceRGB():void 		{			var i:int = numCells;			while ( --i > -1 ) {								r[i] += _dt * rOld[i];				g[i] += _dt * gOld[i];				b[i] += _dt * bOld[i];					}		}				protected function addSource(x:Vector.<Number>, x0:Vector.<Number>):void 		{			var i:int = numCells;			while ( --i > -1 ) {				x[i] += _dt * x0[i];			}		}				protected function advect(b:int, _d:Vector.<Number>, d0:Vector.<Number>, du:Vector.<Number>, dv:Vector.<Number>):void 		{			var i:int, j:int, i0:int, j0:int, i1:int, j1:int, index:int;			var x:Number, y:Number, s0:Number, t0:Number, s1:Number, t1:Number, dt0x:Number, dt0y:Number;						dt0x = _dt * _NX;			dt0y = _dt * _NY;						for (j = _NY; j > 0; --j) {				for (i = _NX; i > 0; --i) {										//index = FLUID_IX(i, j);					index =  int(i + _NX2 * j);					x = i - dt0x * du[index];					y = j - dt0y * dv[index];										if (x > _NX + 0.5) x = _NX + 0.5;					if (x < 0.5) x = 0.5;										i0 = int(x);					i1 = i0 + 1;										if (y > _NY + 0.5) y = _NY + 0.5;					if (y < 0.5) y = 0.5;										j0 = int(y);					j1 = j0 + 1;										s1 = x - i0;					s0 = 1 - s1;					t1 = y - j0;					t0 = 1 - t1;										_d[index] = s0 * (t0 * d0[ int(i0 + _NX2 * j0)] + t1 * d0[ int(i0 + _NX2 * j1)]) + s1 * (t0 * d0[ int(i1 + _NX2 * j0)] + t1 * d0[ int(i1 + _NX2 * j1)]);									}			}			setBoundary(b, _d);		}				protected function advectRGB(du:Vector.<Number>, dv:Vector.<Number>):void 		{			var i:int, j:int, i0:int, j0:int;			var x:Number, y:Number, s0:Number, t0:Number, s1:Number, t1:Number, dt0x:Number, dt0y:Number;			var index:int;						var rl:Vector.<Number> = r;			var gl:Vector.<Number> = g;			var bl:Vector.<Number> = b;			var rOldl:Vector.<Number> = rOld;			var gOldl:Vector.<Number> = gOld;			var bOldl:Vector.<Number> = bOld;									dt0x = _dt * _NX;			dt0y = _dt * _NY;						for (j = _NY; j > 0; --j) 			{				for (i = _NX; i > 0; --i)				{					index = int(i + _NX2 * j);					x = i - dt0x * du[index];					y = j - dt0y * dv[index];										if (x > _NX + 0.5) x = _NX + 0.5;					if (x < 0.5)     x = 0.5;										i0 = int(x);										if (y > _NY + 0.5) y = _NY + 0.5;					if (y < 0.5)     y = 0.5;										j0 = int(y);										s1 = x - i0;					s0 = 1 - s1;					t1 = y - j0;					t0 = 1 - t1;										i0 = int(i0 + _NX2 * j0);                    j0 = i0 + _NX2;                    rl[index] = s0 * ( t0 * rOldl[i0] + t1 * rOldl[j0] ) + s1 * ( t0 * rOldl[int(i0+1)] + t1 * rOldl[int(j0+1)] );                    gl[index] = s0 * ( t0 * gOldl[i0] + t1 * gOldl[j0] ) + s1 * ( t0 * gOldl[int(i0+1)] + t1 * gOldl[int(j0+1)] );                                      bl[index] = s0 * ( t0 * bOldl[i0] + t1 * bOldl[j0] ) + s1 * ( t0 * bOldl[int(i0+1)] + t1 * bOldl[int(j0+1)] );								}			}					}				protected function diffuse(b:int, c:Vector.<Number>, c0:Vector.<Number>, _diff:Number):void 		{			const a:Number = _dt * _diff * _NX * _NY;			linearSolver(b, c, c0, a, 1.0 + 4 * a);		}				protected function diffuseRGB(_diff:Number):void 		{			const a:Number = _dt * _diff * _NX * _NY;			linearSolverRGB(a, 1.0 + 4 * a);		}				protected function diffuseUV(_diff:Number):void 		{			const a:Number = _dt * _diff * _NX * _NY;			linearSolverUV(a, 1.0 + 4 * a);		}				protected function project(x:Vector.<Number>, y:Vector.<Number>, p:Vector.<Number>, div:Vector.<Number>):void 		{			var i:int, j:int;			var index:int;						const h:Number = -0.5 / _NX;						for (j = _NY; j > 0; --j) 	        {				//index = FLUID_IX(_NX, j);				index = int(_NX + _NX2 * j);				for (i = _NX; i > 0; --i)				{					div[index] = h * ( x[int(index+1)] - x[int(index-1)] + y[int(index+_NX2)] - y[int(index-_NX2)] );					p[index] = 0;					--index;				}	        }						setBoundary(0, div);			setBoundary(0, p);						linearSolver(0, p, div, 1, 4);						const fx:Number = 0.5 * _NX;			const fy:Number = 0.5 * _NY;			for (j = _NY; j > 0; --j) 			{				//index = FLUID_IX(_NX, j);				index = int(_NX + _NX2 * j);				for (i = _NX; i > 0; --i)				{					x[index] -= fx * (p[int(index+1)] - p[int(index-1)]);					y[index] -= fy * (p[int(index+_NX2)] - p[int(index-_NX2)]);					--index;				}			}						setBoundary(1, x);			setBoundary(2, y);		}				protected function linearSolver(b:int, x:Vector.<Number>, x0:Vector.<Number>, a:Number, c:Number):void 		{			var k:int, i:int, j:int;						var index:int;						if( a == 1 && c == 4 )			{				for (k = 0; k < _solverIterations; ++k) 				{					for (j = _NY; j > 0 ; --j) 					{						//index = FLUID_IX(_NX, j);						index = int(_NX + _NX2 * j);						for (i = _NX; i > 0 ; --i)						{							x[index] = ( x[int(index-1)] + x[int(index+1)] + x[int(index - _NX2)] + x[int(index + _NX2)] + x0[index] ) * .25;							--index;                                						}					}					setBoundary( b, x );				}			}			else			{				c = 1 / c;				for (k = 0; k < _solverIterations; ++k) 				{					for (j = _NY; j > 0 ; --j) 					{						//index = FLUID_IX(_NX, j);						index = int(_NX + _NX2 * j);						for (i = _NX; i > 0 ; --i)						{							x[index] = ( ( x[int(index-1)] + x[int(index+1)] + x[int(index - _NX2)] + x[int(index + _NX2)] ) * a + x0[index] ) * c;							--index;						}					}					setBoundary( b, x );				}			}		}				protected function linearSolverRGB(a:Number, c:Number):void 		{			var k:int, i:int, j:int;				var index3:int, index4:int, index:int;						c = 1 / c;						for ( k = 0; k < _solverIterations; ++k )			{           			    for (j = _NY; j > 0; --j)			    {			           // index = FLUID_IX(_NX, j );						index = int(_NX + _NX2 * j);						index3 = index - _NX2;						index4 = index + _NX2;						for (i = _NX; i > 0; --i)						{       							r[index] = ( ( r[int(index-1)] + r[int(index+1)]  +  r[index3] + r[index4] ) * a  +  rOld[index] ) * c;							g[index] = ( ( g[int(index-1)] + g[int(index+1)]  +  g[index3] + g[index4] ) * a  +  gOld[index] ) * c;							b[index] = ( ( b[int(index-1)] + b[int(index+1)]  +  b[index3] + b[index4] ) * a  +  bOld[index] ) * c;                                														--index;							--index3;							--index4;						}				}							}		}				protected function linearSolverUV(a:Number, c:Number):void 		{			var ul:Vector.<Number> = u;			var vl:Vector.<Number> = v;			var uOldl:Vector.<Number> = uOld;			var vOldl:Vector.<Number> = vOld;			var nx2:int = _NX2;			var index:int;			var k:int, i:int, j:int;			c = 1 / c;			for (k = 0; k < _solverIterations; ++k) {				for (j = _NY; j > 0; --j) {					index = int(_NX + nx2 * j);					for (i = _NX; i > 0; --i) {						ul[index] = ( ( ul[int(index-1)] + ul[int(index+1)] + ul[int(index - nx2)] + ul[int(index + nx2)] ) * a  +  uOldl[index] ) * c;						vl[index] = ( ( vl[int(index-1)] + vl[int(index+1)] + vl[int(index - nx2)] + vl[int(index + nx2)] ) * a  +  vOldl[index] ) * c;						--index;					}				}				setBoundary( 1, ul );                setBoundary( 2, vl );			}		}				protected function setBoundary(bound:int, x:Vector.<Number>):void 		{			var dst1:int, dst2:int, src1:int, src2:int;			var i:int;						const step:int = _NX2;			dst1 = _NX2;			src1 = 1 + _NX2;			dst2 = _NX + 1 + _NX2;			src2 = _NX + _NX2;									if( bound == 1 ) {				for (i = _NY; i > 0; --i )				{					x[dst1] = -x[src1];     dst1 += step;   src1 += step;   					x[dst2] = -x[src2];     dst2 += step;   src2 += step;   				}			} else {				for (i = _NY; i > 0; --i )				{					x[dst1] = x[src1];      dst1 += step;   src1 += step;   					x[dst2] = x[src2];      dst2 += step;   src2 += step;   				}			}						dst1 = 1;			src1 = 1 + _NX2;			dst2 = 1 + _NX2 * (_NY+1);			src2 = 1 + _NX2 * _NY;						if( bound == 2 ) {				for (i = _NX; i > 0; --i )				{				        x[dst1++] = -x[src1++]; 				        x[dst2++] = -x[src2++]; 				}			} else {				for (i = _NX; i > 0; --i )				{				        x[dst1++] = x[src1++];				        x[dst2++] = x[src2++];  				}			}						x[0] = 0.5 * (x[1] + x[_NX2]);			x[int(_NX2 *(_NY+1))] = 0.5 * (x[int(1 + _NX2 *( _NY+1))] + x[int(_NX2 * _NY)]);			x[int(_NX+1)] = 0.5 * (x[_NX] + x[int(_NX+1 + _NX2)]);			x[int(_NX+1+ _NX2 *( _NY+1))] = 0.5 * (x[int(_NX + _NX2 * (_NY+1))] + x[int(_NX+1 + _NX2 * _NY)]);		}				protected function swapUV():void		{			_tmp = u; 			u = uOld; 			uOld = _tmp;						_tmp = v; 			v = vOld; 			vOld = _tmp; 		}				protected function swapR():void		{ 			_tmp = r;			r = rOld;			rOld = _tmp;		}				protected function swapRGB():void		{ 			_tmp = r;			r = rOld;			rOld = _tmp;						_tmp = g;			g = gOld;			gOld = _tmp;						_tmp = b;			b = bOld;			bOld = _tmp;		}						public function set deltaT(dt:Number):void 		{			_dt = dt;			}				/**		 * @param fadeSpeed (0...1)		 */		public function set fadeSpeed(fadeSpeed:Number):void 		{			_fadeSpeed = fadeSpeed;			}					/**		 * set number of iterations for solver (higher is slower but more accurate) 		 */			public function set solverIterations(solverIterations:int):void 		{			_solverIterations = solverIterations;			}						public function set viscosity(newVisc:Number):void 		{			_visc = newVisc;		}				public function get viscosity():Number 		{			return _visc;		}				public function set colorDiffusion(cd:Number):void		{			_colorDiffusion = cd;		}				public function getIndexForCellPosition(i:int, j:int):int 		{			if(i < 1) i=1; else if(i > _NX) i = _NX;			if(j < 1) j=1; else if(j > _NY) j = _NY;			return int(i + _NX2 * j);		}				public function getIndexForNormalizedPosition(x:Number, y:Number):int 		{			return getIndexForCellPosition(int(x * _NX2), int(y * _NY2));		}						public function get avgDensity():Number 		{			return _avgDensity;		}				public function get uniformity():Number 		{			return _uniformity;		}					public function get avgSpeed():Number 		{			return _avgSpeed;		}	}}